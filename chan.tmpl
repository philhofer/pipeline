{{define "MergeT"}}// Merge merges multiple channels into one
func Merge{{.Esc}}(v ...<-chan {{.}}) <-chan {{.}} {
	wg := new(sync.WaitGroup)
	out := make(chan {{.}})
	for _, c := range v {
		wg.Add(1)
		go func(c <-chan {{.}}) {
			for e := range c {
				out <- e
			}
			wg.Done()
		}(c)
	}
	go func() {
		wg.Wait()
		close(out)
	}()
	return out
}{{end}}

{{define "FanoutT"}}// Fanout splits one channel into 'n' channels
func Fanout{{.Esc}}(v <-chan {{.}}, n int) []<-chan {{.}} {
	out := make([]<-chan {{.}}, 0, n)
	for i := 0; i < n; i++ {
		local := make(chan {{.}})
		go func(c <-chan T, i int, out chan {{.}}) {
			for e := range c {
				out <- e
			}
			close(out)
		}(v, i, local)
		out = append(out, local)
	}
	return out
}{{end}}

{{define "ApplyT"}}// Apply applies 'fs' successively to each element of a channel
// and sends the the object to the output channel.
func Apply{{.Esc}}(v <-chan {{.}}, fs ...func({{.}})) <-chan {{.}} {
	out := make(chan {{.}})
	go func() {
		for e := range v {
			for _, f := range fs {
				f(e)
			}
			out <- e
		}
		close(out)
	}()
	return out
}{{end}}

{{define "PapplyT"}}// Papply applies 'fs' successively to each element received on 'v' and
// sends the object along to the output channel. 'n' goroutines
// are used for processing.
func Papply{{.Esc}}(v <-chan {{.}}, n int, fs ...func({{.}})) <-chan {{.}} {
	out := make(chan {{.}})
	wg := new(sync.WaitGroup)
	wg.Add(n)
	for i := 0; i < n; i++ {
		go func() {
			for e := range v {
				for _, f := range fs {
					f(e)
				}
				out <- e
			}
		}()
	}
	go func() {
		wg.Wait()
		close(out)
	}()
	return out
}{{end}}

{{define "MapT"}}// Map applies 'fs' successively to each element read from
// 'v' and sends them to the output channel.
func Map{{.Esc}}(v <-chan {{.}}, fs ...func({{.}}) {{.}}) <-chan {{.}} {
	out := make(chan {{.}})
	go func() {
		for e := range v {
			for _, f := range fs {
				e = f(e)
			}
			out <- e
		}
		close(out)
	}()
	return out
}{{end}}

{{define "PmapT"}}// Pmap applies 'fs' successively to elements read from 'v' and
// sends the result to the output channel. 'n' goroutines are used
// for processing.
func Pmap{{.Esc}}(v <-chan {{.}}, n int, fs ...func({{.}}) {{.}}) <-chan {{.}} {
	out := make(chan {{.}})
	wg := new(sync.WaitGroup)
	wg.Add(n)
	for i := 0; i < n; i++ {
		go func() {
			for e := range v {
				for _, f := range fs {
					e = f(e)
				}
				out <- e
			}
			wg.Done()
		}()
	}
	go func() {
		wg.Wait()
		close(out)
	}()
	return out
}{{end}}

{{define "FilterT"}}func Filter{{.Esc}}(v <-chan {{.}}, f func({{.}}) bool) <-chan {{.}} {
	out := make(chan {{.}})
	go func() {
		for e := range v {
			if f(e) {
				out <- e
			}
		}
		close(out)
	}()
	return out
}{{end}}

{{define "TransformT"}}// Transform transforms elements from 'v' from {{.Src}} to {{.Dst}} using
// 'f' and sends them on the output channel.
func Transform{{.Esc}}(v <-chan {{.Src}}, f func({{.Src}}) {{.Dst}}) <-chan J {
	out := make(chan {{.Dst}})
	go func() {
		for e := range v {
			out <- f(e)
		}
		close(out)
	}()
	return out
}{{end}}

{{define "PtransformT"}}// Ptransform performs Transform{{.Esc}}() in parallel using 'n' goroutines.
func Ptransform{{.Esc}}(v <-chan {{.Src}}, f func({{.Src}}) {{.Dst}}, n int) <-chan {{.Dst}} {
	out := make(chan {{.Dst}})
	wg := new(sync.WaitGroup)
	wg.Add(n)
	for i := 0; i < n; i++ {
		go func() {
			for e := range v {
				out <- f(e)
			}
			wg.Done()
		}()
	}
	go func() {
		wg.Wait()
		close(out)
	}()
	return out
}{{end}}